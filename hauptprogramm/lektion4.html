<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>Kapitel 4: Die Zugriffssprache SQL</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
          margin: 0;
          font-family: 'Segoe UI', sans-serif;
          background: linear-gradient(135deg, #0b0e1a, #11142d 80%);
          color: #f0f0f0;
          padding: 2rem;
          text-align: center;
          min-height: 100vh;
          position: relative;
        }
        body::before, body::after {
          content: "";
          position: fixed;
          border-radius: 50%;
          filter: blur(100px);
          z-index: 0;
          opacity: 0.3;
        }
        body::before {
          width: 340px; height: 340px;
          background: #00f2ff;
          top: -100px; left: -120px;
        }
        body::after {
          width: 270px; height: 270px;
          background: #23d2ff;
          bottom: -80px; right: -60px;
        }
        h1 {
          color: #00f2ff;
          margin-bottom: 0.3em;
          font-size: 2.6rem;
          letter-spacing: 0.02em;
          z-index: 2;
          position: relative;
        }
        .welcome-text {
          font-size: 1.23rem;
          margin-bottom: 2.2rem;
          color: #b8c3d3;
          z-index: 2;
          position: relative;
        }
        .tab-buttons {
          display: flex;
          flex-wrap: wrap;
          justify-content: center;
          gap: 1.3rem;
          margin-bottom: 2.3rem;
          z-index: 2;
          position: relative;
        }
        .tab-buttons button {
          background: #1a1e33;
          border: 2.2px solid #00f2ff;
          color: #00f2ff;
          padding: 0.95rem 2.1rem;
          border-radius: 2.2rem;
          cursor: pointer;
          font-weight: bold;
          font-size: 1.13rem;
          letter-spacing: 0.02em;
          transition:
            background 0.25s,
            color 0.22s,
            border-color 0.23s,
            box-shadow 0.28s,
            transform 0.19s;
          box-shadow: 0 1px 12px 0 rgba(0,242,255,0.04);
          display: flex;
          align-items: center;
          gap: 0.5em;
        }
        .tab-buttons button.active,
        .tab-buttons button:focus-visible {
          background: linear-gradient(90deg,#00f2ff 60%,#38f8ff 100%);
          color: #11142d;
          border-color: #c6f9ff;
          transform: scale(1.07);
          box-shadow: 0 2px 18px 0 #00f2ff40, 0 2px 6px 0 #0002;
        }
        .tab-buttons button:hover:not(.active) {
          box-shadow: 0 0 0 2px #00f2ff70;
          border-color: #00f2ff;
          background: #212755;
          color: #fff;
        }
        .lesson-content {
          background: #1c1f35ea;
          padding: 2.8rem 2.2rem;
          border-radius: 1.4rem;
          max-width: 860px;
          margin: 2.5rem auto 0 auto;
          box-shadow: 0 8px 38px 0 #00f2ff18, 0 3px 12px 0 #0003;
          text-align: left;
          line-height: 1.8;
          font-size: 1.09rem;
          position: relative;
          border: 1.5px solid rgba(0,242,255,0.11);
          opacity: 0;
          transform: translateY(24px) scale(0.99);
          pointer-events: none;
          transition:
            opacity 0.45s cubic-bezier(.42,1.35,.49,1),
            transform 0.33s cubic-bezier(.42,1.25,.54,1.12);
          z-index: 2;
        }
        .lesson-content.visible {
          opacity: 1;
          pointer-events: auto;
          transform: translateY(0) scale(1);
        }
        .lesson-content h2 {
          color: #00f2ff;
          font-size: 1.6rem;
          margin-bottom: 0.7em;
        }
        .lesson-content ul {
          margin-top: 1.5rem;
          margin-bottom: 2rem;
          padding-left: 1.5rem;
          list-style-type: disc;
        }
        .lesson-content li {
          margin-bottom: 0.8rem;
        }
        .subsection-buttons {
          display: grid;
          grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
          gap: 0.85rem 1.2rem;
          margin-bottom: 1.8rem;
          margin-top: 1.8rem;
        }
        .subsection-buttons button {
          background: #181e32;
          border: 2px solid #00f2ff;
          color: #00f2ff;
          padding: 0.70rem 0.2rem;
          border-radius: 1.4rem;
          font-size: 1rem;
          font-weight: 600;
          transition:
            background 0.21s,
            color 0.22s,
            border-color 0.23s,
            box-shadow 0.28s,
            transform 0.19s;
          box-shadow: 0 1px 8px 0 #00f2ff20;
          cursor: pointer;
        }
        .subsection-buttons button.active,
        .subsection-buttons button:focus-visible {
          background: linear-gradient(90deg,#00f2ff 60%,#38f8ff 100%);
          color: #11142d;
          border-color: #fff;
          transform: scale(1.06);
          box-shadow: 0 2px 18px 0 #00f2ff2c, 0 2px 6px 0 #0001;
        }
        .subsection-buttons button:hover:not(.active) {
          background: #00f2ff22;
          color: #fff;
          border-color: #38f8ff;
          box-shadow: 0 0 0 2px #00f2ff40;
        }
        .sub-content {
          margin-top: 2rem;
        }
        .sub-content h3 {
          color: #00f2ff;
          font-size: 1.22rem;
        }
                .btn-verstanden {
          margin-top: 1.4rem;
          background: #181e32;
          border: 2px solid #00f2ff;
          color: #00f2ff;
          padding: 0.6rem 1.2rem;
          border-radius: 1.2rem;
          font-weight: 600;
          cursor: pointer;
          transition:
            background 0.21s,
            color 0.22s,
            border-color 0.23s,
            box-shadow 0.28s,
            transform 0.19s;
          box-shadow: 0 1px 8px 0 #00f2ff20;
        }
        .btn-verstanden:hover {
          background: #00f2ff22;
          color: #fff;
          border-color: #38f8ff;
          box-shadow: 0 0 0 2px #00f2ff40;
        }
        /* Responsive f√ºr kleine Screens */
        @media (max-width: 600px) {
          .lesson-content { padding: 1.2rem 0.7rem; }
          .tab-buttons { gap: 0.4rem; }
          .tab-buttons button { padding: 0.5rem 0.9rem; font-size: 0.98rem; }
        }
         .header-row{display:flex;justify-content:space-between;align-items:center;margin-bottom:1.5rem;}
  .btn-dashboard{display:inline-block;background-color:#8b5cf6;color:#fff;padding:0.6rem 1.5rem;border-radius:1.2rem;font-weight:bold;text-decoration:none;transition:background 0.3s,transform 0.2s;}
  .btn-dashboard:hover{background-color:#a78bfa;transform:scale(1.05);}
  .header-row .btn-dashboard{margin-top:0;}
    </style>
</head>
<body>
<header class="header-row">
    <h1>Kapitel 4: Die Zugriffssprache SQL</h1>
    <a href="dashboard.html" class="btn-dashboard">‚Üê Zur√ºck zum Dashboard</a>
</header>
<p class="welcome-text">W√§hle einen Bereich, um zu starten:</p>
<div class="tab-buttons">
    <button data-index="0"> 4.1 Select-Befehl</button>
    <button data-index="1"> 4.2 Mutationsbefehle</button>
    <button data-index="2"> 4.3 Transaktionen</button>
    <button data-index="3"> 4.4 Algebra & SQL</button>
    <button data-index="4"> 4.5 Zusammenfassung</button>
    <button data-index="5"> 4.6 √úbungsaufgaben</button>
    <button data-index="6"> Literatur</button>
</div>
<div class="lesson-content" id="lessonContent"></div>
<script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>

<script>
    const sections = [
      {
        title: "4.1 Der Abfragebefehl Select",
        description: "Hier lernst du den Aufbau und die Funktionsweise des wichtigsten SQL-Befehls: SELECT.",
        subsections: [
          { name: "4.1.1 Aufbau des Select-Befehls", content: `<h3>4.1.1 Der Aufbau des Select-Befehls</h3>
    <p><b>Wichtig zu wissen:</b><br>
    SQL fragt nicht <i>wie</i> Daten gefunden werden, sondern nur <i>welche</i> Daten gesucht werden.<br>
    Egal, wie die Datenbank intern organisiert ist (Index, Reihenfolge, etc.): Das SQL-Statement bleibt gleich!
    </p>
    <p>
    <b>Das macht SQL besonders einfach und flexibel.</b> F√ºr dich hei√üt das: Fokus auf den gew√ºnschten Inhalt, nicht auf technische Details.
    </p>
    <h4>Syntax: Select-Hauptteil</h4>
    <pre><code>
    SELECT [ ALL | DISTINCT ] Spaltenauswahlliste
    FROM   Tabellenliste
    [ WHERE Bedingung ]
    [ GROUP BY Spaltenliste
      [ HAVING Bedingung ] ]
    </code></pre>
    <ul>
      <li><b>Gro√übuchstaben</b> = reservierte W√∂rter (so schreiben)</li>
      <li><b>Eckige Klammern [ ]</b> = optional, werden <i>nicht</i> mitgeschrieben</li>
      <li><b>Geschweifte Klammern { }</b> mit Strich | = Auswahlliste, eins davon w√§hlen</li>
      <li><b>Drei Punkte ...</b> = beliebig oft wiederholen</li>
      <li><b>Bezeichner:</b> Beginnen mit Buchstaben (ohne √§, √∂, √º, √ü), dann Buchstaben, Unterstrich (_), Ziffern</li>
    </ul>
    <h4>Erweiterte Syntax: Vollst√§ndiger Select-Befehl</h4>
    <pre><code>
    Select-Hauptteil
    [ UNION [ALL] | EXCEPT | INTERSECT Select-Hauptteil ] [ ... ]
    [ ORDER BY Ordnungsliste ]
    </code></pre>
    <ul>
      <li>Ein <b>Select-Befehl</b> besteht aus mindestens einem Hauptteil</li>
      <li>Weitere Select-Teile k√∂nnen mit UNION, EXCEPT, INTERSECT verbunden werden</li>
      <li>Abschlie√üend kann das Ergebnis mit <b>ORDER BY</b> sortiert werden</li>
    </ul>
    <h4>Reihenfolge der Abarbeitung</h4>
    <ol>
      <li><b>FROM</b> ‚Äì Welche Tabelle(n)?</li>
      <li><b>WHERE</b> ‚Äì Einschr√§nkung/Filter</li>
      <li><b>SELECT</b> ‚Äì Was soll angezeigt werden?</li>
      <li><b>GROUP BY/HAVING</b> ‚Äì Gruppierung (optional)</li>
    </ol>
    <p>
    <i>Tipp:</i> Lies und schreibe Selects am besten immer in dieser Reihenfolge!
    </p>
    <h4>Vergleich SQL & Relationale Algebra</h4>
    <table border="1" cellpadding="4" style="margin-bottom:10px;">
      <thead>
        <tr><th>Algebra</th><th>SQL</th></tr>
      </thead>
      <tbody>
        <tr><td>Vereinigung</td><td>UNION</td></tr>
        <tr><td>Schnitt</td><td>INTERSECT</td></tr>
        <tr><td>Differenz</td><td>EXCEPT</td></tr>
        <tr><td>Kreuzprodukt</td><td>Tabellenliste</td></tr>
        <tr><td>Restriktion (œÉ)</td><td>WHERE</td></tr>
        <tr><td>Projektion (œÄ)</td><td>SELECT</td></tr>
        <tr><td>Verbund</td><td>Tabellenliste</td></tr>
        <tr><td>Division</td><td><i>nicht in SQL</i></td></tr>
        <tr><td>Umbenennung</td><td>Spaltenauswahlliste, Tabellenliste</td></tr>
      </tbody>
    </table>
    <small>
    <b>Hinweis:</b> Die Syntax basiert auf der SQL2-Norm.<br>
    Unterschiede zu Oracle, SQL Server, MySQL werden jeweils im Text gekennzeichnet.
    </small>
          `},
          { name: "4.1.2 Die From-Klausel", content: `<h3>4.1.2 Die From-Klausel</h3>
<p>
  Jeder Select-Befehl enth√§lt eine <b>Select-</b> und eine <b>From-Klausel</b>. Die From-Klausel verbindet in der Tabellenliste die Relationen √ºber Kreuzprodukt oder Verbund (Join). Die Select-Klausel macht dann eine Projektion auf die gew√ºnschten Spalten.
</p>
<p>
  <b>Syntax Tabellenliste:</b><br>
  <code>Tabellenreferenz [, ...]</code>
</p>
<ul>
  <li><b>Eine Tabellenreferenz</b>: z.B. nur ein Tabellenname (SELECT * FROM Personal;)</li>
  <li><b>Mehrere Tabellenreferenzen</b>: Kommagetrennt = Kreuzprodukt<br>
    <code>SELECT * FROM Personal, Auftrag;</code>
  </li>
</ul>

<p>
  <b>Definition Tabellenreferenz:</b>
  <pre style="white-space:pre-line; background:#121423; border-radius:0.5em; padding:0.8em 1em; color:#9cf;">
Tabellenname [[AS] Aliasname]
| (Select-Hauptteil) [[AS] Aliasname]
| (Tabellenreferenz) [[AS] Aliasname]
| Joinausdruck [[AS] Aliasname]
  </pre>
</p>

<ul>
  <li><b>Tabellenname</b>: wie immer, optional mit Alias.<br>
    <code>SELECT * FROM Personal AS P;</code>
  </li>
  <li><b>Select in Klammern:</b> ein Subquery als Tabelle (erfordert Alias in MySQL/SQL Server).<br>
    <code>SELECT * FROM (SELECT * FROM Personal) AS P2;</code>
  </li>
  <li><b>Klammern um Tabellennamen:</b> selten n√∂tig, eher f√ºr komplexere Ausdr√ºcke.<br>
    <code>SELECT * FROM (Personal);</code>
  </li>
  <li><b>Joinausdruck:</b> direkt JOIN in der FROM-Klausel.<br>
    <code>SELECT * FROM Personal NATURAL INNER JOIN Auftrag;</code>
  </li>
</ul>

<p>
  <b>Beispiele Tabellenliste:</b><br>
  <code>SELECT * FROM Personal, Auftrag;</code>
  <br>
  <small>(Kreuzprodukt: jede Zeile von Personal mit jeder Zeile von Auftrag.)</small>
</p>

<p>
  <b>Kreuzprodukt - Ergebnisbeispiel:</b>
  <br>
  (Die ersten 11 Zeilen einer Ergebnistabelle, gek√ºrzt.)
</p>
<table border="1" cellpadding="4">
<thead>
<tr>
  <th>Persnr</th><th>Name</th><th>Ort</th><th>AuftrNr</th><th>Datum</th><th>Kundnr</th><th>Persnr (Auftrag)</th>
</tr>
</thead>
<tbody>
<tr><td>1</td><td>Maria Forster</td><td>Regensburg</td><td>1</td><td>04.01.13</td><td>1</td><td>2</td></tr>
<tr><td>1</td><td>Maria Forster</td><td>Regensburg</td><td>2</td><td>06.01.13</td><td>3</td><td>5</td></tr>
<tr><td>1</td><td>Maria Forster</td><td>Regensburg</td><td>3</td><td>07.01.13</td><td>4</td><td>2</td></tr>
<tr><td>1</td><td>Maria Forster</td><td>Regensburg</td><td>4</td><td>18.01.13</td><td>6</td><td>5</td></tr>
<tr><td>1</td><td>Maria Forster</td><td>Regensburg</td><td>5</td><td>06.02.13</td><td>1</td><td>2</td></tr>
<tr><td>2</td><td>Anna Kraus</td><td>Regensburg</td><td>1</td><td>04.01.13</td><td>1</td><td>2</td></tr>
<tr><td>2</td><td>Anna Kraus</td><td>Regensburg</td><td>2</td><td>06.01.13</td><td>3</td><td>5</td></tr>
<tr><td>2</td><td>Anna Kraus</td><td>Regensburg</td><td>3</td><td>07.01.13</td><td>4</td><td>2</td></tr>
<tr><td>2</td><td>Anna Kraus</td><td>Regensburg</td><td>4</td><td>18.01.13</td><td>6</td><td>5</td></tr>
<tr><td>2</td><td>Anna Kraus</td><td>Regensburg</td><td>5</td><td>06.02.13</td><td>1</td><td>2</td></tr>
<tr><td>3</td><td>Ursula Rank</td><td>Frankfurt</td><td>1</td><td>04.01.13</td><td>1</td><td>2</td></tr>
</tbody>
</table>

<p>
  <b>Relationale Algebra (zum Vergleich):</b>
  <pre style="background:#121423; border-radius:0.5em; padding:0.5em 1em; color:#9cf;">
Personal!P  (Umbenennung) <br>
Personal √ó Auftrag  (Kreuzprodukt)
  </pre>
</p>
<p>
  <b>Hinweise:</b><br>
  - <b>AS</b> ist in Oracle <u>nicht</u> in der FROM-Klausel erlaubt.<br>
  - In MySQL/SQL Server muss bei Subqueries <u>immer</u> ein Alias vergeben werden.
</p>
<p>
  <i>Erst in Kombination mit Projektion (SELECT) und Restriktion (WHERE) wird die FROM-Klausel wirklich n√ºtzlich.</i>
</p>
` },
          { name: "4.1.3 Die Select-Klausel", content: `<h3>4.1.3 Die Select-Klausel</h3>
<p>
  Die <b>Select-Klausel</b> bestimmt, welche Daten du ausgeben willst. Sie hat die Syntax:<br>
  <code>SELECT [ ALL | DISTINCT ] Spaltenauswahlliste</code>
</p>
<ul>
  <li>
    <b>Spaltenauswahlliste:</b> Kommagetrennte Spaltenausdr√ºcke.<br>
    <code>SELECT Name, Gehalt FROM Personal;</code>
  </li>
  <li>
    Es sind auch beliebige Ausdr√ºcke erlaubt ‚Äì inklusive arithmetischer Operationen, Funktionen oder sogar Unterabfragen.
  </li>
  <li>
    <b>Aliasnamen:</b> Mit <code>AS</code> (oder direkt) kannst du Spalten umbenennen.<br>
    <code>SELECT Name, 12 * Gehalt AS Jahresgehalt FROM Personal;</code>
  </li>
</ul>

<h4>Sternsymbol *</h4>
<p>
  Gibt alle Spalten aus.<br>
  <code>SELECT * FROM Personal, Auftrag;</code><br>
  <b>Tipp:</b> Nutze <code>*</code> nur f√ºr schnelle Abfragen, in Programmen besser immer die Spalten einzeln angeben!
</p>
<p>
  Spaltennamen lassen sich qualifizieren:<br>
  <code>SELECT Personal.Persnr, Name, Auftrag.AuftrNr FROM Personal, Auftrag;</code>
</p>

<h4>Skalare Funktionen in SQL</h4>
<p>Einige n√ºtzliche Funktionen:</p>
<ul>
  <li><b>UPPER(Zeichenkette)</b>: alles gro√ü</li>
  <li><b>LOWER(Zeichenkette)</b>: alles klein</li>
  <li><b>TRIM(Zeichenkette)</b>: entfernt Leerzeichen vorne und hinten</li>
  <li><b>RTRIM(Zeichenkette)</b>: entfernt Leerzeichen rechts</li>
  <li><b>SUBSTRING(Zeichenkette, Pos, Anzahl)</b> oder <b>SUBSTRING(Zeichenkette FROM Pos FOR Anzahl)</b></li>
</ul>
<small>
  Hinweis: Manche Datenbanken haben Besonderheiten! In Oracle z.B. hei√üt <code>SUBSTR()</code> statt <code>SUBSTRING()</code>.
</small>

<h4>Aggregatfunktionen (Statistiken)</h4>
<table border="1" cellpadding="4">
  <thead>
    <tr><th>Funktion</th><th>Bedeutung</th></tr>
  </thead>
  <tbody>
    <tr><td>AVG()</td><td>Mittelwert</td></tr>
    <tr><td>COUNT()</td><td>Anzahl Zeilen</td></tr>
    <tr><td>MAX()</td><td>Maximalwert</td></tr>
    <tr><td>MIN()</td><td>Minimalwert</td></tr>
    <tr><td>SUM()</td><td>Summe</td></tr>
  </tbody>
</table>
<p>
  Beispiel:<br>
  <code>SELECT SUM(12 * Gehalt + 1000 * (6-Beurteilung)) AS PersonalkostenJahr FROM Personal;</code>
</p>
<p>
  <b>COUNT(*)</b> z√§hlt alle Zeilen (auch mit NULL), <b>COUNT(Spalte)</b> z√§hlt nur Zeilen mit Wert in dieser Spalte.
</p>
<p>
  <b>ALL</b> und <b>DISTINCT</b> k√∂nnen verwendet werden, z.B.:<br>
  <code>SELECT DISTINCT Ort FROM Personal;</code> ‚Äì Jeder Ort nur einmal.<br>
  <code>SELECT COUNT(DISTINCT Vorgesetzt) FROM Personal;</code> ‚Äì Anzahl verschiedener Vorgesetzte.
</p>

<h4>Zusammenfassung ‚Äì Wichtige Hinweise</h4>
<ul>
  <li>Mit <code>SELECT DISTINCT ...</code> werden doppelte Zeilen entfernt.</li>
  <li>Aggregatfunktionen liefern immer nur einen Wert zur√ºck, au√üer sie stehen mit <b>GROUP BY</b> in Kombination.</li>
  <li><b>NULL-Werte</b> werden bei Aggregaten (au√üer COUNT(*)) ignoriert.</li>
  <li>Spaltennamen bei gleichnamigen Attributen <b>immer qualifizieren</b> (Tabellenname.Spalte).</li>
</ul>
` },
          { name: "4.1.4 Die Where-Klausel", content: `<h3>4.1.4 Die WHERE-Klausel</h3>
<p>
  Die <b>WHERE-Klausel</b> ist das Werkzeug zur <b>Filterung von Daten</b> ‚Äì sie schr√§nkt die Ergebnismenge auf die Zeilen ein, die die angegebene Bedingung erf√ºllen.
</p>
<p>
  <b>Syntax:</b><br>
  <code>SELECT ... FROM ... WHERE Bedingung;</code>
</p>
<ul>
  <li>Die <b>WHERE-Klausel</b> kommt nach FROM, aber vor SELECT in der logischen Auswertung.</li>
  <li>Sie enth√§lt einen <b>booleschen Ausdruck</b> (wahr/falsch): Nur Zeilen, die <b>wahr</b> ergeben, kommen ins Ergebnis.</li>
</ul>

<h4>Wichtige Operatoren:</h4>
<table border="1" cellpadding="4">
  <thead>
    <tr><th>Typ</th><th>Operatoren</th></tr>
  </thead>
  <tbody>
    <tr><td>Boolesche</td><td>NOT, AND, OR</td></tr>
    <tr><td>Vergleich</td><td>&lt;, &lt;=, &gt;, &gt;=, =, &lt;&gt;, !=</td></tr>
    <tr><td>Intervall</td><td>[NOT] BETWEEN ... AND ...</td></tr>
    <tr><td>Mengen</td><td>[NOT] IN (...)</td></tr>
    <tr><td>√Ñhnlichkeit</td><td>[NOT] LIKE (Wildcards: % und _)</td></tr>
    <tr><td>Nullwerte</td><td>IS [NOT] NULL</td></tr>
    <tr><td>Auswahl</td><td>ALL, ANY, SOME</td></tr>
    <tr><td>Existenz</td><td>EXISTS (mit Unterabfragen)</td></tr>
  </tbody>
</table>

<h4>Beispiele:</h4>
<ul>
  <li>
    <b>Wert gr√∂√üer als ...</b><br>
    <code>SELECT * FROM Personal WHERE Gehalt &gt; 3000;</code>
  </li>
  <li>
    <b>Wert zwischen zwei Zahlen:</b><br>
    <code>SELECT * FROM Personal WHERE Gehalt BETWEEN 2000 AND 3000;</code>
  </li>
  <li>
    <b>Wert in einer Menge:</b><br>
    <code>SELECT * FROM Personal WHERE Gehalt IN (2300, 2700, 3300);</code>
  </li>
  <li>
    <b>LIKE ‚Äì Mustervergleich (Wildcards):</b><br>
    <code>SELECT * FROM Personal WHERE Name LIKE '%Heinz%';</code><br>
    (Name enth√§lt "Heinz")<br>
    <code>SELECT * FROM Personal WHERE UPPER(Name) LIKE '%A_E%';</code>
  </li>
  <li>
    <b>Nullwerte testen:</b><br>
    <code>SELECT * FROM Personal WHERE Vorgesetzt IS NULL;</code>
  </li>
</ul>

<h4>Unterabfragen (Subselects) in WHERE</h4>
<p>
  <b>Unterabfragen</b> erlauben es, Bedingungen von Ergebnissen anderer SELECTs abh√§ngig zu machen.
</p>
<code>
SELECT * FROM Personal<br>
WHERE Ort IN (SELECT Ort FROM Personal WHERE Persnr IN (2, 5));
</code>
<p>Oder mit Auswahloperatoren:</p>
<code>
SELECT * FROM Personal<br>
WHERE Gehalt &gt;= ALL (SELECT Gehalt FROM Personal);
</code>

<h4>EXISTS-Operator</h4>
<p>
  Pr√ºft, ob die Unterabfrage mindestens ein Ergebnis liefert:
</p>
<code>
SELECT * FROM Personal AS P1<br>
WHERE EXISTS (SELECT * FROM Personal WHERE Persnr = 3 AND P1.Gehalt &lt; Gehalt);
</code>

<h4>Wichtige Hinweise</h4>
<ul>
  <li>Vergleiche auf NULL immer mit <code>IS NULL</code> bzw. <code>IS NOT NULL</code>! <br><i>(<code>= NULL</code> oder <code>&lt;&gt; NULL</code> funktioniert nicht!)</i></li>
  <li>Aggregatfunktionen (z.B. MAX()) sind in WHERE direkt <b>nicht</b> erlaubt, nur in Subselects.</li>
  <li>Klammern helfen bei komplexen Bedingungen und machen sie √ºbersichtlicher.</li>
</ul>
` },
          { name: "4.1.5 Group By & Having", content: `<h3>4.1.5 Die <span style="color:#00f2ff">GROUP BY</span>- und <span style="color:#00f2ff">HAVING</span>-Klausel</h3>
<p>
  Mit <b>GROUP BY</b> k√∂nnen Datens√§tze nach bestimmten Spalten <b>gruppiert</b> und mit Aggregatfunktionen ausgewertet werden.
  <br>Die <b>HAVING</b>-Klausel filtert die Gruppen nach der Aggregation.
</p>

<h4>GROUP BY ‚Äì Gruppieren nach Spalten</h4>
<p>
  So kann man z.B. alle Wohnorte von Mitarbeitern einmalig ausgeben:
</p>
<pre><code>SELECT Ort
FROM Personal
GROUP BY Ort;
</code></pre>
<ul>
  <li>In <b>GROUP BY</b> d√ºrfen <b>nur Spaltennamen</b> stehen (keine Ausdr√ºcke!).</li>
  <li>In <b>SELECT</b> d√ºrfen nach einer Gruppierung <b>nur Spalten stehen, die gruppiert werden</b> oder Aggregatfunktionen enthalten.</li>
</ul>

<h4>Gruppieren & Z√§hlen: Wie viele wohnen in welchem Ort?</h4>
<pre><code>SELECT Ort, COUNT(*) AS Anzahl
FROM Personal
GROUP BY Ort;
</code></pre>
<p>
  Ergebnis:
  <br>
  <table border="1" cellpadding="4">
    <thead>
      <tr><th>Ort</th><th>Anzahl</th></tr>
    </thead>
    <tbody>
      <tr><td>Regensburg</td><td>3</td></tr>
      <tr><td>Frankfurt</td><td>1</td></tr>
      <tr><td>N√ºrnberg</td><td>2</td></tr>
      <tr><td>Landshut</td><td>1</td></tr>
      <tr><td>Augsburg</td><td>1</td></tr>
      <tr><td>Stuttgart</td><td>1</td></tr>
    </tbody>
  </table>
</p>

<h4>HAVING ‚Äì Gruppen filtern (nach der Aggregation!)</h4>
<p>
  Beispiel: Nur Orte mit mindestens 2 Mitarbeitern UND dazu Statistik:
</p>
<pre><code>
SELECT Ort, COUNT(*) AS Anzahl, SUM(12*Gehalt) AS Jahresgehalt, 12 * MAX(Gehalt) AS MaxJahresgehalt
FROM Personal
GROUP BY Ort
HAVING COUNT(*) &gt; 1;
</code></pre>
<ul>
  <li><b>HAVING</b> filtert die Gruppen <i>nach</i> der Gruppierung ‚Äì im Gegensatz zu <b>WHERE</b> (filtert <i>vor</i> der Gruppierung).</li>
  <li>Nur hier sind Aggregatfunktionen im Filter erlaubt!</li>
</ul>

<h4>Alternative mit Subquery (statt HAVING):</h4>
<pre><code>
SELECT *
FROM (
  SELECT Ort, COUNT(*) AS Anzahl,
         SUM(12*Gehalt) AS Jahresgehalt,
         12 * MAX(Gehalt) AS MaxJahresgehalt
  FROM Personal
  GROUP BY Ort
) AS Zwischentabelle
WHERE Anzahl &gt; 1;
</code></pre>

<h4>Aggregieren √ºber Unterabfragen</h4>
<p>
  Durchschnittliches Auftragsvolumen pro Auftrag und im Mittel:
</p>
<pre><code>
SELECT 'Mittleres Auftragsvolumen:', AVG(Auftragsvolumen)
FROM (
  SELECT SUM(Gesamtpreis) AS Auftragsvolumen
  FROM Auftragsposten
  GROUP BY Auftrnr
) AS Auftragspreis;
</code></pre>

<ul>
  <li><b>GROUP BY</b> ist sehr m√§chtig f√ºr Statistiken & Reports ‚Äì wird z.B. im Data Warehouse oft eingesetzt.</li>
  <li><b>HAVING</b> ohne GROUP BY ist auch m√∂glich (dann wirkt es wie ein WHERE auf Aggregatfunktionen √ºber die ganze Tabelle).</li>
</ul>

<small><b>Hinweis:</b> GROUP BY hat keine Entsprechung in der relationalen Algebra.</small>
` },
          { name: "4.1.6 Union, Except und Intersect", content: `<h3>4.1.6 <span style="color:#00f2ff">UNION</span>, <span style="color:#00f2ff">EXCEPT</span> und <span style="color:#00f2ff">INTERSECT</span></h3>
<p>
  Mit diesen ‚ÄûMengenoperatoren‚Äú kannst du Ergebnismengen von SELECT-Anweisungen miteinander <b>verkn√ºpfen</b>.
</p>
<ul>
  <li><b>UNION</b>: Vereinigung (liefert alle unterschiedlichen Tupel beider Ergebnismengen)</li>
  <li><b>EXCEPT</b>: Differenz (liefert alle Tupel aus dem ersten SELECT, die nicht im zweiten vorkommen)</li>
  <li><b>INTERSECT</b>: Schnitt (liefert alle Tupel, die in beiden Ergebnismengen vorkommen)</li>
</ul>

<h4>Wichtige Voraussetzungen</h4>
<ul>
  <li>Beide SELECTs m√ºssen die <b>gleiche Anzahl an Spalten</b> liefern (gleicher ‚ÄûGrad‚Äú).</li>
  <li>Die Spalten m√ºssen <b>typ-kompatibel</b> sein (z.B. beide Zahlen, beide Text).</li>
  <li><b>INTERSECT</b> bindet st√§rker als UNION oder EXCEPT. <br>Klammern d√ºrfen und sollten zur Steuerung der Reihenfolge genutzt werden.</li>
</ul>

<h4>Beispiel: Vereinigung aller Orte aus Personal <i>und</i> Kunde</h4>
<pre><code>
SELECT Ort
FROM Personal
UNION
SELECT Ort
FROM Kunde;
</code></pre>
<ul>
  <li><b>UNION</b> entfernt doppelte Werte (wie die Relationenalgebra).</li>
  <li>Willst du Duplikate behalten (performanter): <b>UNION ALL</b></li>
</ul>

<h4>Beispiel: Unterschied (EXCEPT)</h4>
<pre><code>
SELECT Ort
FROM Personal
EXCEPT
SELECT Ort
FROM Kunde;
</code></pre>
<ul>
  <li>Liefert alle Orte, die es in <b>Personal</b>, aber nicht in <b>Kunde</b> gibt.</li>
  <li><b>Hinweis:</b> In Oracle hei√üt EXCEPT: <b>MINUS</b></li>
</ul>

<h4>Beispiel: Schnitt (INTERSECT)</h4>
<pre><code>
SELECT Ort
FROM Personal
INTERSECT
SELECT Ort
FROM Kunde;
</code></pre>
<ul>
  <li>Liefert alle Orte, die sowohl bei <b>Personal</b> als auch bei <b>Kunde</b> vorkommen.</li>
</ul>

<small>
  <b>Hinweis:</b> In MySQL ist nur <b>UNION</b> (und <b>UNION ALL</b>) verf√ºgbar, <b>INTERSECT</b> und <b>EXCEPT</b> gibt es dort (noch) nicht direkt.<br>
  <b>UNION ALL</b> ist performanter, weil keine Pr√ºfung auf Duplikate gemacht wird!
</small>
` },
          { name: "4.1.7 Der Verbund (Join)", content: `<h3>4.1.7 Der Verbund (Join)</h3>
<p>
  Der <b>JOIN-Operator</b> verbindet mehrere Tabellen (Relationen) zu einer Ergebnismenge, typischerweise √ºber gemeinsame Spalten. Joins sind extrem wichtig in der Praxis, besonders f√ºr Fremdschl√ºsselbeziehungen.
</p>

<h4>Grundsyntax</h4>
<pre><code>
SELECT ...
FROM Tabelle1
[ {NATURAL} ] [INNER]
  | [NATURAL] {LEFT | RIGHT | FULL} [OUTER]
JOIN Tabelle2
ON Bedingung
</code></pre>
<ul>
  <li>Die wichtigsten Varianten sind <b>INNER JOIN</b> (Standard-Join) und <b>NATURAL JOIN</b> (Join √ºber gleichnamige Spalten).</li>
  <li>Die Join-Bedingung wird mit <b>ON</b> oder <b>USING</b> angegeben.</li>
</ul>

<h4>Beispiel: Nat√ºrlicher Join</h4>
<pre><code>
SELECT *
FROM Auftrag NATURAL INNER JOIN Personal;
</code></pre>
<ul>
  <li>Alle Datens√§tze aus <b>Auftrag</b> und <b>Personal</b>, bei denen die <b>Persnr</b> √ºbereinstimmt, werden zusammengef√ºhrt.</li>
  <li>Die gemeinsame Spalte erscheint nur einmal im Ergebnis.</li>
</ul>

<h4>Beispiel: Join mit ON-Bedingung</h4>
<pre><code>
SELECT *
FROM Auftrag
INNER JOIN Personal
  ON Auftrag.Persnr = Personal.Persnr;
</code></pre>
<ul>
  <li>Die Verbindung erfolgt explizit √ºber die Spalte <code>Persnr</code>.</li>
  <li>Alle gemeinsamen Datens√§tze werden angezeigt ‚Äì auch wenn die Spaltennamen unterschiedlich w√§ren!</li>
</ul>

<h4>Beispiel: Join mit USING</h4>
<pre><code>
SELECT *
FROM Auftrag
INNER JOIN Personal
  USING (Persnr);
</code></pre>
<ul>
  <li>Wie NATURAL JOIN, aber du bestimmst selbst die Join-Spalte(n).</li>
</ul>

<h4>Join mit Projektion (nur gew√ºnschte Spalten ausgeben)</h4>
<pre><code>
SELECT Auftrnr, Datum, Kundnr, Personal.*
FROM Auftrag
INNER JOIN Personal
  ON Auftrag.Persnr = Personal.Persnr;
</code></pre>
<p>
  So kannst du doppelte Spalten vermeiden und die Ergebnismenge √ºbersichtlich halten.
</p>

<h4>Alternative: Join als WHERE-Bedingung (√§lterer Stil)</h4>
<pre><code>
SELECT Auftrnr, Datum, Kundnr, Personal.*
FROM Auftrag, Personal
WHERE Auftrag.Persnr = Personal.Persnr;
</code></pre>
<ul>
  <li>Das klassische SQL (Kreuzprodukt + WHERE-Filterung)</li>
  <li>Empfohlen wird aber heute der <b>JOIN ... ON ...</b>-Stil.</li>
</ul>

<h4>Theta-Join</h4>
<p>
  Du kannst im <b>ON</b> auch beliebige Vergleichsoperatoren nutzen, nicht nur ‚Äû=‚Äú.<br>
  <small>Beispiel: <code>ON Personal.Gehalt &gt; Auftrag.Summe</code></small>
</p>

<small>
  <b>Hinweise:</b>
  <ul>
    <li>In MySQL gibt es keinen FULL JOIN; Oracle verwendet <b>MINUS</b> statt EXCEPT und unterst√ºtzt <b>NATURAL JOIN</b>.</li>
    <li>Im SQL Server gibt es kein NATURAL JOIN/USING, dort immer <b>ON</b> verwenden.</li>
    <li>Joins k√∂nnen beliebig geschachtelt werden.</li>
    <li>Join ist das Standardmittel, um Daten aus mehreren Tabellen logisch zu verbinden!</li>
  </ul>
</small>
` },
          { name: "4.1.8 Der √§u√üere Verbund (Outer Join)", content: `<h3>4.1.8 Der √§u√üere Verbund (Outer Join)</h3>
<p>
  Im Unterschied zum <b>INNER JOIN</b> liefert der <b>OUTER JOIN</b> auch Datens√§tze, f√ºr die es auf einer Seite <b>keine Entsprechung</b> gibt. Typische Anwendung: Du willst <i>alle</i> Mitarbeitenden auflisten ‚Äì auch wenn sie (noch) keine Auftr√§ge haben.
</p>

<!-- Grafische Darstellung Outer Joins -->
<div style="display: flex; flex-wrap: wrap; gap: 2.5rem; justify-content:center; margin: 1.2em 0 2em 0;">
  <div style="text-align:center;">
    <b>LEFT OUTER JOIN</b>
    <div style="font-size:1.8em;">üü¶<b>‚äï</b>üü©</div>
    <div style="display:inline-block;background:#0df2c01c;border-radius:8px;padding:0.8em 1.1em;margin-top:0.7em;">
      <span style="color:#00f2ff;">Alle links,<br>passende rechts</span>
    </div>
  </div>
  <div style="text-align:center;">
    <b>RIGHT OUTER JOIN</b>
    <div style="font-size:1.8em;">üü¶<b>‚äï</b>üü©</div>
    <div style="display:inline-block;background:#23aaff19;border-radius:8px;padding:0.8em 1.1em;margin-top:0.7em;">
      <span style="color:#23d2ff;">Alle rechts,<br>passende links</span>
    </div>
  </div>
  <div style="text-align:center;">
    <b>FULL OUTER JOIN</b>
    <div style="font-size:1.8em;">üü¶<b>‚äï</b>üü©</div>
    <div style="display:inline-block;background:#d3f2ff12;border-radius:8px;padding:0.8em 1.1em;margin-top:0.7em;">
      <span style="color:#38f8ff;">Alle aus beiden,<br>egal ob passend</span>
    </div>
  </div>
</div>

<!-- Syntax & Beispiele -->
<h4>Syntax</h4>
<pre><code>
SELECT ...
FROM Tabelle1
LEFT [OUTER] JOIN Tabelle2 ON Bedingung

SELECT ...
FROM Tabelle1
RIGHT [OUTER] JOIN Tabelle2 ON Bedingung

SELECT ...
FROM Tabelle1
FULL [OUTER] JOIN Tabelle2 ON Bedingung
</code></pre>
<ul>
  <li><b>LEFT OUTER JOIN</b>: Alle Zeilen von <b>links</b> (Tabelle1), auch wenn keine passenden von rechts</li>
  <li><b>RIGHT OUTER JOIN</b>: Alle Zeilen von <b>rechts</b> (Tabelle2), auch wenn keine passenden von links</li>
  <li><b>FULL OUTER JOIN</b>: Alle Zeilen aus beiden Tabellen, nicht passende werden mit <code>NULL</code> erg√§nzt</li>
</ul>

<h4>Beispiel: Alle Mitarbeiter mit/ohne Auftr√§ge</h4>
<pre><code>
SELECT Persnr, Name, COUNT(AuftrNr) AS AnzahlAuftrag
FROM Personal NATURAL LEFT OUTER JOIN Auftrag
GROUP BY Persnr, Name;
</code></pre>
<p>
  Ergebnis: <br>
  <i>Auch Mitarbeitende, die keine Auftr√§ge haben, werden mit ausgegeben (Anzahl = 0)</i>
</p>

<!-- Farbig gestaltete Ergebnis-Tabelle -->
<table style="border-collapse:collapse;margin:1.4em auto;width:95%;background:#151b2b;border-radius:1.2em;overflow:hidden;box-shadow:0 1px 12px #00f2ff18;">
  <thead style="background:#112e3d;">
    <tr>
      <th style="padding:0.75em 1.1em;color:#00f2ff;">Persnr</th>
      <th style="padding:0.75em 1.1em;color:#00f2ff;">Name</th>
      <th style="padding:0.75em 1.1em;color:#00f2ff;">AnzahlAuftrag</th>
    </tr>
  </thead>
  <tbody>
    <tr><td style="padding:0.7em 1em;">2</td><td>Anna Kraus</td><td style="color:#0fd;">3</td></tr>
    <tr><td>5</td><td>Johanna K√∂ster</td><td style="color:#0fd;">2</td></tr>
    <tr style="background:#26324e77;"><td>1</td><td>Maria Forster</td><td style="color:#ffc;">0</td></tr>
    <tr><td>3</td><td>Ursula Rank</td><td style="color:#ffc;">0</td></tr>
    <tr style="background:#26324e77;"><td>4</td><td>Heinz Rolle</td><td style="color:#ffc;">0</td></tr>
    <tr><td>6</td><td>Marianne Lambert</td><td style="color:#ffc;">0</td></tr>
    <tr style="background:#26324e77;"><td>7</td><td>Thomas Noster</td><td style="color:#ffc;">0</td></tr>
    <tr><td>8</td><td>Renate Wolters</td><td style="color:#ffc;">0</td></tr>
    <tr style="background:#26324e77;"><td>9</td><td>Ernst Pach</td><td style="color:#ffc;">0</td></tr>
  </tbody>
</table>

<h4>Hinweise zur Praxis</h4>
<ul>
  <li>Das Wort <b>OUTER</b> ist optional: <code>LEFT JOIN</code> ist dasselbe wie <code>LEFT OUTER JOIN</code>.</li>
  <li>In <b>MySQL</b> gibt es <i>kein</i> FULL OUTER JOIN, nur LEFT/RIGHT OUTER JOIN.</li>
  <li>In <b>SQL Server</b> wird <code>NATURAL</code> nicht unterst√ºtzt, stattdessen <code>ON</code> verwenden.</li>
  <li>Verwende f√ºr Z√§hlungen von Auftr√§gen <code>COUNT(AuftrNr)</code> (statt <code>COUNT(*)</code>), damit du "0" f√ºr leere Zeilen bekommst.</li>
  <li><b>FULL OUTER JOIN</b> nur nutzen, wenn wirklich n√∂tig, da meist langsam und wenig gebraucht.</li>
</ul>

<h4>Outer Join als UNION nachbauen</h4>
<pre><code>
SELECT Persnr, Name, COUNT(*) AS AnzahlAuftrag
FROM Personal NATURAL INNER JOIN Auftrag
GROUP BY Persnr, Name
UNION
SELECT Persnr, Name, 0
FROM Personal
WHERE Persnr NOT IN (SELECT Persnr FROM Auftrag);
</code></pre>
<p>
  So funktioniert ein Outer Join "zu Fu√ü": Erst normale Verbund-Ergebnisse, dann fehlende mit 0 erg√§nzen.
</p>

<small>
  <b>Merke:</b> Nutze <span style="color:#00f2ff;">ON</span> oder <span style="color:#00f2ff;">USING</span> statt <span style="color:#00f2ff;">NATURAL</span> f√ºr mehr Kontrolle. <br>
  Verwende Outer Joins gezielt, wenn du wirklich alle Datens√§tze aus einer oder beiden Tabellen brauchst!
</small>
` },
          { name: "4.1.9 Die Order-By-Klausel", content: `<h3>4.1.9 Die Order-By-Klausel</h3>
<p>
  In einer relationalen Datenbank ist die Reihenfolge der Daten **grunds√§tzlich beliebig** ‚Äì das Ergebnis eines <b>SELECT</b> ist <i>immer ungeordnet</i>. Doch in der Praxis willst du meistens sortierte Listen!
</p>

<h4>Order By: Syntax und Beispiele</h4>
<pre><code>
SELECT ...
FROM ...
[WHERE ...]
ORDER BY Attribut1 [ASC|DESC], Attribut2 [ASC|DESC], ...
</code></pre>
<ul>
  <li>Du kannst <b>beliebig viele</b> Sortierkriterien angeben ‚Äì durch Komma getrennt.</li>
  <li>Standardm√§√üig wird <b>aufsteigend</b> (<code>ASC</code>) sortiert. F√ºr <b>absteigend</b> <code>DESC</code> angeben.</li>
  <li>Du kannst auch <b>Spaltennummern</b> (beginnend bei 1) statt Namen nutzen, z.B. <code>ORDER BY 2 DESC, 1</code>.</li>
</ul>

<h4>Beispiel: Wohnorte nach Mitarbeiterzahl sortiert</h4>
<pre><code>
SELECT Ort, COUNT(*) AS Anzahl
FROM Personal
GROUP BY Ort
ORDER BY Anzahl DESC, Ort;
</code></pre>
<p>Das Ergebnis k√∂nnte so aussehen:</p>

<table style="border-collapse:collapse;margin:1.4em auto;width:330px;background:#151b2b;border-radius:1em;box-shadow:0 1px 10px #00f2ff11;">
  <thead style="background:#112e3d;">
    <tr>
      <th style="padding:0.6em 1em;color:#00f2ff;">Ort</th>
      <th style="padding:0.6em 1em;color:#00f2ff;">Anzahl</th>
    </tr>
  </thead>
  <tbody>
    <tr><td>Regensburg</td><td style="color:#0fd;">3</td></tr>
    <tr><td>N√ºrnberg</td><td>2</td></tr>
    <tr><td>Frankfurt</td><td>1</td></tr>
    <tr><td>Landshut</td><td>1</td></tr>
    <tr><td>Augsburg</td><td>1</td></tr>
    <tr><td>Stuttgart</td><td>1</td></tr>
  </tbody>
</table>

<h4>Sortierreihenfolge: ASC & DESC</h4>
<ul>
  <li><b>ASC</b>: aufsteigend (Standard, kann weggelassen werden)</li>
  <li><b>DESC</b>: absteigend (z. B. bei Zahlen, Datum, Alphabet)</li>
</ul>
<pre><code>
ORDER BY Name ASC, Gehalt DESC
</code></pre>

<h4>Praxis-Tipps</h4>
<ul>
  <li>Nutze <b>Attributnamen</b> statt Spaltennummern f√ºr bessere Lesbarkeit!</li>
  <li>Du kannst auch auf <b>Aliase</b> sortieren (<code>COUNT(*) AS Anzahl</code> ‚Üí <code>ORDER BY Anzahl</code>)</li>
  <li>Komplexe Ausdr√ºcke zuerst als Alias anlegen, dann sortieren</li>
</ul>

<small>
  <b>Hinweis:</b> Die Sortierung passiert <i>nach</i> der Auswahl und Gruppierung der Daten!
</small>
` },
          { name: "4.1.10 Nullwerte und Coalesce", content: `<h3>4.1.10 Nullwerte und die Coalesce-Funktion</h3>
<p>
  <b>Nullwerte</b> (= fehlende Angaben in der Datenbank) sind oft die Ursache f√ºr merkw√ºrdige SQL-Ergebnisse oder leere Ausgaben. In SQL steht <code>NULL</code> f√ºr "unbekannt" ‚Äì <b>nicht</b> f√ºr 0 oder einen leeren String!
</p>

<div style="margin: 1.3em 0; background: #1e293b; border-radius: 1em; padding: 1.4em 1.7em;">
  <h4 style="color:#00f2ff;margin-top:0;">Regel Nr. 1: Vergleiche nie direkt mit <code>NULL</code></h4>
  <p>
    <b>Falsch:</b> <code>WHERE Attribut = NULL</code> <br>
    <b>Richtig:</b> <code>WHERE Attribut IS NULL</code> <br>
    <b>Oder:</b> <code>WHERE Attribut IS NOT NULL</code>
  </p>
</div>

<h4>Praxisfalle: "Gleicher Chef?"</h4>
<pre><code>
SELECT Name, Gehalt, Vorgesetzt
FROM Personal
WHERE Vorgesetzt = (
  SELECT Vorgesetzt
  FROM Personal
  WHERE Persnr = 1
);
</code></pre>
<p>
  <b>Was passiert?</b> Mitarbeiterin 1 hat <code>Vorgesetzt = NULL</code>. SQL vergleicht aber nie zwei Nullwerte direkt ‚Äì das Ergebnis ist immer <b>leer</b>. Selbst andere Mitarbeitende mit <code>NULL</code> werden nicht ausgegeben!
</p>

<div style="margin:1.5em 0; background: #1e293b; border-radius: 1em; padding: 1.2em 1.5em;">
  <h4 style="color:#00f2ff;margin-top:0;">Regel Nr. 2: Nullwerte in Berechnungen & Aggregaten</h4>
  <ul>
    <li>Nullwerte machen einen ganzen Ausdruck zu NULL (<b>kein Wert</b>!)</li>
    <li>SUM, AVG, MAX, MIN ignorieren Zeilen mit NULL ‚Äì <code>COUNT(*)</code> z√§hlt trotzdem alle.</li>
  </ul>
</div>

<h4>Beispiel: Jahrespersonalkosten falsch berechnet?</h4>
<pre><code>
SELECT SUM(12*Gehalt+1000*(6-Beurteilung)) AS Jahrespersonalkosten
FROM Personal;
</code></pre>
<p>
  <b>Was passiert?</b> Gibt es Mitarbeitende mit <code>Beurteilung = NULL</code>, dann wird der ganze Ausdruck f√ºr diese Person zu <code>NULL</code>. Diese Zeile fehlt in der Gesamtsumme!
</p>

<div style="background: #222c3c; border-radius: 1em; padding: 1em 1.3em; margin:1.3em 0;">
  <h4 style="color:#00f2ff;margin-top:0;">Die Rettung: COALESCE</h4>
  <p>
    Die Funktion <b>COALESCE(expr1, expr2)</b> gibt den ersten <i>nicht-NULL</i> Wert zur√ºck. Sie ist ideal, um Standardwerte f√ºr NULLs festzulegen!
  </p>
  <pre><code>
SELECT SUM(12 * Gehalt + COALESCE(1000*(6-Beurteilung), 1000))
AS Jahrespersonalkosten
FROM Personal;
  </code></pre>
  <p>
    <b>Erkl√§rung:</b> Ist <code>1000*(6-Beurteilung)</code> NULL, wird stattdessen <b>1000</b> addiert!
  </p>
</div>

<h4>COALESCE im Outer Join</h4>
<pre><code>
SELECT Persnr, Name, COALESCE(SUM(Gesamtpreis), 0) AS Summe
FROM Personal
LEFT OUTER JOIN Auftrag ON ...
GROUP BY Persnr, Name;
</code></pre>
<p>
  So bekommen Mitarbeitende ohne Auftr√§ge eine <b>0</b> statt NULL als Summe angezeigt!
</p>

<div style="margin:1.2em 0 0 0; background: #223444; border-radius: 0.8em; padding: 1em;">
  <span style="color:#00f2ff;"><b>Tipp:</b></span> Die <b>Coalesce-Funktion</b> ist √ºberall dort sinnvoll, wo dir NULL im Ergebnis unangenehm auff√§llt oder du mit eigenen Standardwerten weiterrechnen willst.
</div>
` },
          { name: "4.1.11 Arbeitsweise des Select", content: `<h3>4.1.11 Arbeitsweise des Select-Befehls</h3>
<p>
  Der <b>SELECT-Befehl</b> wirkt manchmal wie Magie ‚Äì in Wirklichkeit folgt SQL aber immer einer klaren Abarbeitungsreihenfolge!
  Um Fehler zu vermeiden und effiziente Abfragen zu schreiben, solltest du diese Reihenfolge gut kennen und beim Lesen oder Planen von SELECTs immer einhalten.
</p>

<!-- Grafik: Flussdiagramm der Reihenfolge -->
<div style="display: flex; justify-content: center; margin: 2em 0;">
  <svg width="480" height="270" viewBox="0 0 480 270">
    <style>
      .step { fill: #10162a; stroke: #00f2ff; stroke-width:2; }
      .step-label { fill: #00f2ff; font-size: 16px; font-family: Segoe UI, Arial, sans-serif; text-anchor: middle;}
      .arrow { stroke: #23d2ff; stroke-width:2; marker-end:url(#arrowhead);}
    </style>
    <defs>
      <marker id="arrowhead" markerWidth="8" markerHeight="8" refX="5" refY="2" orient="auto" markerUnits="strokeWidth">
        <polygon points="0 0, 8 2, 0 4" fill="#23d2ff"/>
      </marker>
    </defs>
    <rect x="140" y="12" width="200" height="32" rx="10" class="step"/>
    <text x="240" y="33" class="step-label">1. FROM (Verbund, Kreuzprodukt)</text>
    <line x1="240" y1="44" x2="240" y2="66" class="arrow"/>
    <rect x="140" y="66" width="200" height="32" rx="10" class="step"/>
    <text x="240" y="87" class="step-label">2. WHERE (Restriktion)</text>
    <line x1="240" y1="98" x2="240" y2="120" class="arrow"/>
    <rect x="140" y="120" width="200" height="32" rx="10" class="step"/>
    <text x="240" y="141" class="step-label">3. SELECT (Projektion)</text>
    <line x1="240" y1="152" x2="240" y2="174" class="arrow"/>
    <rect x="140" y="174" width="200" height="32" rx="10" class="step"/>
    <text x="240" y="195" class="step-label">4. GROUP BY / HAVING</text>
    <line x1="240" y1="206" x2="240" y2="218" class="arrow"/>
    <rect x="140" y="218" width="200" height="32" rx="10" class="step"/>
    <text x="240" y="239" class="step-label">5. UNION, INTERSECT, EXCEPT</text>
    <line x1="240" y1="250" x2="240" y2="262" class="arrow"/>
    <text x="240" y="268" fill="#b8c3d3" font-size="15px" text-anchor="middle">6. ORDER BY (Sortierung)</text>
  </svg>
</div>

<p style="margin-top: 2em;">
  <b>Merke dir:</b> <br>
  <ol style="margin-left: 1.5em;">
    <li><b>FROM:</b> Welche Tabellen/Relationen? Kreuzprodukt & Verbund werden berechnet.</li>
    <li><b>WHERE:</b> Einschr√§nkungen/Filter (Restriktion) ‚Äì nur passende Zeilen bleiben √ºbrig.</li>
    <li><b>SELECT:</b> Welche Spalten/Attribute sollen ausgegeben werden? (Projektion)</li>
    <li><b>GROUP BY / HAVING:</b> Gruppieren & nach Gruppen filtern (Aggregatfunktionen nutzen).</li>
    <li><b>UNION / INTERSECT / EXCEPT:</b> Mengenoperationen, mehrere Teilabfragen verbinden.</li>
    <li><b>ORDER BY:</b> Am Ende sortieren!</li>
  </ol>
</p>

<div style="background: #1e293b; border-radius: 1em; padding: 1.1em 1.4em; margin:1.6em 0;">
  <b style="color:#00f2ff">Praxis-Tipp:</b> <br>
  Schreibe oder pr√ºfe SELECT-Befehle immer in dieser Reihenfolge. So verhinderst du Fehler und erkennst, warum manche Ergebnisse unerwartet ausfallen.
</div>

<h4>Beispiel (kompletter SELECT):</h4>
<pre><code>
SELECT Ort, COUNT(*) AS Anzahl
FROM Personal
WHERE Gehalt > 2000
GROUP BY Ort
HAVING COUNT(*) &gt; 1
ORDER BY Anzahl DESC;
</code></pre>
<ul>
  <li><b>FROM</b>: Personal</li>
  <li><b>WHERE</b>: Nur Gehalt &gt; 2000</li>
  <li><b>SELECT</b>: Ort, Anzahl</li>
  <li><b>GROUP BY</b>: Ort</li>
  <li><b>HAVING</b>: Nur Orte mit &gt;1 MA</li>
  <li><b>ORDER BY</b>: Nach Anzahl absteigend</li>
</ul>

<div style="margin-top: 2em; color:#b8c3d3;">
  <span style="color:#00f2ff;"><b>Fazit:</b></span> <br>
  <b>Wer die Abarbeitungsreihenfolge kennt, kann auch komplexe SELECTs locker analysieren und gestalten!</b>
</div>
` },
        ]
      },
      {
        title: "4.2 Mutationsbefehle in SQL",
        description: "Lerne, wie du mit SQL Daten einf√ºgst, ver√§nderst oder l√∂schst.",
        content: `<h2>4.2 Mutationsbefehle in SQL</h2>
<p>
  Nicht nur lesen ‚Äì auch <b>Daten ver√§ndern</b> ist mit SQL m√∂glich! Drei Befehle stehen daf√ºr bereit:<br>
  <b>INSERT</b> (einf√ºgen), <b>UPDATE</b> (√§ndern), <b>DELETE</b> (l√∂schen).
</p>

<!-- Grafik -->
<div style="display:flex; gap:2em; justify-content:center; margin:2em 0 1em 0; flex-wrap:wrap">
  <div style="background:#1a1e33;border-radius:1.2em;padding:1.3em 2.3em;box-shadow:0 2px 18px #00f2ff18;min-width:170px;">
    <div style="font-size:2.3em;">‚ûï</div>
    <b>INSERT</b><br>
    <span style="color:#85f4f4;">F√ºgt neue Zeilen ein</span>
  </div>
  <div style="background:#1a1e33;border-radius:1.2em;padding:1.3em 2.3em;box-shadow:0 2px 18px #00f2ff18;min-width:170px;">
    <div style="font-size:2.3em;">üìù</div>
    <b>UPDATE</b><br>
    <span style="color:#85f4f4;">√Ñndert bestehende Zeilen</span>
  </div>
  <div style="background:#1a1e33;border-radius:1.2em;padding:1.3em 2.3em;box-shadow:0 2px 18px #00f2ff18;min-width:170px;">
    <div style="font-size:2.3em;">üóëÔ∏è</div>
    <b>DELETE</b><br>
    <span style="color:#85f4f4;">L√∂scht Zeilen</span>
  </div>
</div>

<h3>DELETE ‚Äì Zeilen l√∂schen</h3>
<div style="background:#1e293b;padding:1.1em 1.6em;border-radius:1em;margin:1em 0;">
  <pre><code>DELETE FROM Tabellenname [WHERE Bedingung];</code></pre>
  <ul>
    <li>Ohne <code>WHERE</code> werden <b>alle</b> Zeilen gel√∂scht!</li>
    <li>Mit <code>WHERE</code> kannst du gezielt filtern.</li>
  </ul>
</div>
<b>Beispiel:</b>
<pre><code>DELETE FROM Personal WHERE Name = 'Ursula Rank';</code></pre>
<b>Achtung:</b> <span style="color:#ffc857">DELETE ohne WHERE entfernt die ganze Tabelle!</span>

<hr style="margin:2.5em 0">

<h3>UPDATE ‚Äì Zeilen √§ndern</h3>
<div style="background:#1e293b;padding:1.1em 1.6em;border-radius:1em;margin:1em 0;">
  <pre><code>UPDATE Tabellenname
SET Spalte = Ausdruck [, ...]
[WHERE Bedingung];</code></pre>
  <ul>
    <li>Mehrere Spalten lassen sich gleichzeitig √§ndern.</li>
    <li>Auch hier ist <code>WHERE</code> sehr wichtig!</li>
  </ul>
</div>
<b>Beispiel:</b>
<pre><code>UPDATE Personal
SET Gehalt = 1.05 * Gehalt
WHERE Gehalt &lt; 3000;</code></pre>
<b>Hinweis:</b> Mit <code>SET Spalte = NULL</code> setzt du einen Wert auf Null.

<hr style="margin:2.5em 0">

<h3>INSERT ‚Äì Zeilen einf√ºgen</h3>
<div style="background:#1e293b;padding:1.1em 1.6em;border-radius:1em;margin:1em 0;">
  <pre><code>INSERT INTO Tabellenname [(Spaltenliste)]
VALUES (Wert1, Wert2, ...)[, (...), ...];

ODER

INSERT INTO Tabellenname [(Spaltenliste)]
SELECT ...</code></pre>
  <ul>
    <li>Mit <code>VALUES</code> eine oder mehrere Zeilen direkt angeben.</li>
    <li>Mit <code>SELECT</code> neue Zeilen aus anderen Tabellen erzeugen.</li>
  </ul>
</div>
<b>Beispiel 1 (einzelne Zeile):</b>
<pre><code>INSERT INTO Personal (Persnr, Name, GebDatum, Ort)
VALUES (10, 'Lars Anger', DATE '1980-01-13', 'Augsburg');</code></pre>
<b>Beispiel 2 (mehrere Zeilen):</b>
<pre><code>INSERT INTO Personal (Persnr, Name, GebDatum, Ort)
VALUES
  (10, 'Lars Anger', DATE '1980-01-13', 'Augsburg'),
  (11, 'Karl Meier', DATE '1983-05-15', 'Darmstadt');</code></pre>
<b>Beispiel 3 (Daten aus anderer Zeile √ºbernehmen):</b>
<pre><code>INSERT INTO Personal(Persnr, Name, GebDatum, Vorgesetzt, Gehalt)
SELECT 10, 'Lars Anger', DATE '1980-01-13', Vorgesetzt, Gehalt
FROM Personal
WHERE Persnr = 7;</code></pre>

<hr style="margin:2.5em 0 1.5em 0">

<div style="background:#0b1120;color:#fffa;padding:1em 1.4em;border-radius:0.9em;margin-bottom:2em;">
  <b style="color:#00f2ff;">Sicherheits-Tipp:</b> <br>
  <span style="color:#ffc857;">Verwende immer eine <code>WHERE</code>-Klausel bei DELETE & UPDATE,</span>
  <br>sonst ver√§nderst du versehentlich ALLE Zeilen der Tabelle!
</div>

<ul style="margin: 2.5em 0 0 0;">
  <li><b style="color:#00f2ff">INSERT:</b> Neuen Datensatz einf√ºgen</li>
  <li><b style="color:#00f2ff">UPDATE:</b> Bestehenden Datensatz √§ndern</li>
  <li><b style="color:#00f2ff">DELETE:</b> Datensatz l√∂schen</li>
</ul>
`
      },
      {
        title: "4.3 Transaktionsbetrieb mit SQL",
        description: "Verstehe Transaktionen, Commit und Rollback in SQL.",
        content: `<h2>4.3 Transaktionsbetrieb mit SQL</h2>
<p>
  Wenn Daten in der Datenbank <b>ver√§ndert</b> werden, ist Sicherheit und Kontrolle Pflicht! <br>
  <b>Transaktionen</b> sorgen daf√ºr, dass √Ñnderungen entweder vollst√§ndig (‚Äûganz oder gar nicht‚Äú) durchgef√ºhrt werden oder r√ºckg√§ngig gemacht werden k√∂nnen.
</p>

<div style="display:flex; gap:1.7em;flex-wrap:wrap;justify-content:center;margin:2em 0;">
  <div style="background:#14202e;padding:1.1em 2em;border-radius:1.2em;min-width:180px;">
    <span style="font-size:1.5em;">‚úÖ</span> <b>COMMIT</b><br>
    <span style="color:#64f5d9;">Speichert alle √Ñnderungen dauerhaft</span>
  </div>
  <div style="background:#14202e;padding:1.1em 2em;border-radius:1.2em;min-width:180px;">
    <span style="font-size:1.5em;">‚Ü©Ô∏è</span> <b>ROLLBACK</b><br>
    <span style="color:#ffb84c;">Macht alle √Ñnderungen seit dem letzten COMMIT r√ºckg√§ngig</span>
  </div>
</div>

<h3>Wie funktionieren Transaktionen?</h3>
<ul>
  <li>Eine Transaktion ist eine <b>Gruppe von SQL-Befehlen</b> (INSERT/UPDATE/DELETE), die zusammen als ‚ÄûEinheit‚Äú betrachtet werden.</li>
  <li>Mit <code>COMMIT;</code> werden alle √Ñnderungen <b>dauerhaft</b> gespeichert.</li>
  <li>Mit <code>ROLLBACK;</code> wird die komplette Transaktion <b>r√ºckg√§ngig</b> gemacht.</li>
</ul>

<div style="background:#0b1120;color:#fff3;padding:1em 1.4em;border-radius:0.9em;margin:2em 0;">
  <b style="color:#00f2ff;">Wichtig:</b> <br>
  Nach jedem COMMIT/ROLLBACK beginnt automatisch die n√§chste Transaktion!
</div>

<h3>Syntax</h3>
<pre style="background:#1e293b;color:#fff;padding:1em 1.5em;border-radius:1em;"><code>COMMIT;    -- √Ñnderungen speichern<br>ROLLBACK;  -- √Ñnderungen verwerfen (zur√ºcksetzen)</code></pre>

<h3>Praxisbeispiel</h3>
<p>
  Angenommen, du √ºberweist 1000‚Ç¨ von Konto A zu Konto B. Beide √Ñnderungen (A und B) sollen <b>immer zusammen</b> passieren ‚Äì nie nur eine allein!
</p>
<pre style="background:#1e293b;color:#fff;padding:1em 1.5em;border-radius:1em;">
<code>UPDATE Bank SET Saldo = Saldo - 1000 WHERE Konto = 'A';
UPDATE Bank SET Saldo = Saldo + 1000 WHERE Konto = 'B';
COMMIT;</code>
</pre>
<ul>
  <li><b>Nach dem COMMIT:</b> Die √úberweisung ist endg√ºltig!</li>
  <li><b>Vor dem COMMIT:</b> Kannst du per <code>ROLLBACK;</code> alles zur√ºcksetzen.</li>
</ul>

<div style="background:#14202e;color:#f0f0f0;padding:1em 1.5em;border-radius:1em;margin:2em 0;">
  <b>Tipp:</b><br>
  Bei Fehlern oder versehentlichen √Ñnderungen kannst du mit <code>ROLLBACK;</code> die Datenbank in den <b>letzten konsistenten Zustand</b> zur√ºckversetzen.
</div>

<h3>Extra: BEGIN TRANSACTION</h3>
<ul>
  <li>In <b>Oracle</b> & MySQL wird die Transaktion meist automatisch gestartet.</li>
  <li>In <b>SQL Server</b> oder bei manchen Programmiersprachen (z.B. PHP/PDO) beginnt man explizit mit:<br>
    <code>BEGIN TRANSACTION;</code>
  </li>
</ul>

<h4 style="margin-top:2em">Das ACID-Prinzip</h4>
<ul>
  <li><b>Atomarit√§t:</b> Alles oder nichts (COMMIT oder ROLLBACK)</li>
  <li><b>Konsistenz:</b> Datenbank bleibt immer ‚Äûkorrekt‚Äú</li>
  <li><b>Isolation:</b> Transaktionen beeinflussen sich nicht gegenseitig</li>
  <li><b>Dauerhaftigkeit:</b> Nach COMMIT sind Daten sicher gespeichert</li>
</ul>

<div style="background:#1a1e33;border-left:5px solid #00f2ff;padding:1em 1.7em;border-radius:0.8em;margin-top:2em;">
  <b style="color:#00f2ff;">Merke:</b> <br>
  <b>COMMIT</b> = alles speichern, <b>ROLLBACK</b> = alles zur√ºcksetzen.<br>
  <span style="color:#ffc857;">Nie vergessen, regelm√§√üig zu committen oder bei Fehlern zu rollen!</span>
</div>
`
      },
      {
        title: "4.4 Relationale Algebra und SQL",
        description: "Vergleiche die relationale Algebra mit SQL-Befehlen.",
        content: `<h2>4.4 Relationale Algebra und SQL</h2>
<p>
  Die <b>relationale Algebra</b> bildet die mathematische Grundlage f√ºr SQL. Mit den SQL-Befehlen kannst du <b>alle wichtigen Operatoren</b> der relationalen Algebra abbilden und kombinieren!
</p>

<div style="background:#14202e;padding:1.2em 2em;border-radius:1.2em;margin:2em 0;">
  <b>Vergleichstabelle: Relationale Algebra &rarr; SQL</b>
  <table border="0" style="margin-top:1em;width:100%;color:#f0f0f0;border-collapse:separate;border-spacing:0 0.6em;">
    <thead style="color:#00f2ff;">
      <tr><th align="left">Operator</th><th align="left">Algebra</th><th align="left">SQL-Befehl</th></tr>
    </thead>
    <tbody>
      <tr><td>Vereinigung</td><td><code>R1 ‚à™ R2</code></td><td><code>SELECT * FROM R1 UNION SELECT * FROM R2</code></td></tr>
      <tr><td>Kreuzprodukt</td><td><code>R1 √ó R2</code></td><td><code>SELECT * FROM R1, R2</code></td></tr>
      <tr><td>Restriktion (Filter)</td><td><code>œÉ_b(R)</code></td><td><code>SELECT * FROM R WHERE b</code></td></tr>
      <tr><td>Projektion (Spaltenauswahl)</td><td><code>œÄ_x1,...,xn(R)</code></td><td><code>SELECT x1, ..., xn FROM R</code></td></tr>
      <tr><td>Differenz</td><td><code>R1 ‚àñ R2</code></td><td><code>SELECT * FROM R1 EXCEPT SELECT * FROM R2</code></td></tr>
      <tr><td>Verbund (Join)</td><td><code>R1 ‚®ù R2</code></td><td><code>SELECT * FROM R1 NATURAL JOIN R2</code></td></tr>
      <tr><td>Schnitt</td><td><code>R1 ‚à© R2</code></td><td><code>SELECT * FROM R1 INTERSECT SELECT * FROM R2</code></td></tr>
      <tr><td>Umbenennung</td><td>‚Äì</td><td><code>SELECT ... AS ...</code> oder <code>... AS ...</code> in FROM</td></tr>
      <tr><td>Division</td><td>‚Äì</td><td><i>Kein direkter Operator! (Workaround mit Unterabfragen)</i></td></tr>
    </tbody>
  </table>
</div>

<h3>Beispiel: Division per SQL mit Unterabfragen</h3>
<p>
  Die <b>Division</b> ist in SQL <i>nicht direkt implementiert</i>, aber du kannst sie mit <b>GROUP BY</b>, <b>HAVING</b> und Unterabfragen nachbilden. Hier ein Klassiker: ‚ÄûFinde alle Lieferanten, die mindestens die gleichen Artikel wie Lieferant 3 liefern‚Äú.
</p>
<pre style="background:#1e293b;color:#fff;padding:1em 1.5em;border-radius:1em;">
<code>SELECT Liefnr
FROM Lieferung
WHERE Anr IN ( SELECT Anr FROM Lieferung WHERE Liefnr = 3 )
GROUP BY Liefnr
HAVING COUNT(*) = (
  SELECT COUNT(*) FROM Lieferung WHERE Liefnr = 3
);
</code></pre>

<ul>
  <li>Im <b>WHERE</b> wird zuerst auf die relevanten Artikel von Lieferant 3 gefiltert.</li>
  <li><b>GROUP BY</b> gruppiert nach Lieferant.</li>
  <li><b>HAVING</b> pr√ºft, ob die Anzahl der gelieferten Artikel gleich gro√ü ist wie bei Lieferant 3.</li>
</ul>

<div style="background:#00f2ff14;padding:1em 1.7em;border-left:6px solid #00f2ff;border-radius:0.9em;margin:2em 0;">
  <b style="color:#00f2ff;">Fazit:</b> <br>
  SQL bildet alle Grundoperationen der relationalen Algebra nach ‚Äì <br>
  nur die <b>Division</b> ben√∂tigt etwas ‚ÄûTricksen‚Äú mit Unterabfragen &amp; Gruppierung.
</div>
`
      },
      {
        title: "4.5 Zusammenfassung",
        description: "Wichtige Erkenntnisse zu SQL im √úberblick.",
        content: `<h2>4.5 Zusammenfassung</h2>
<div style="background:#162032;padding:1.4em 2em;border-radius:1.2em;margin:2em 0 2em 0;">
  <b style="color:#00f2ff;">SQL im √úberblick:</b>
  <ul style="line-height:1.8;">
    <li>Nur <b>vier Grundbefehle</b> reichen zum Arbeiten mit relationalen Datenbanken:
      <span style="color:#00f2ff;">SELECT</span> (Abfragen),
      <span style="color:#00f2ff;">UPDATE</span> (√Ñndern),
      <span style="color:#00f2ff;">INSERT</span> (Einf√ºgen),
      <span style="color:#00f2ff;">DELETE</span> (L√∂schen)
    </li>
    <li>F√ºr Transaktionen kommen noch <span style="color:#00f2ff;">COMMIT</span> und <span style="color:#00f2ff;">ROLLBACK</span> dazu.</li>
    <li><b>SELECT</b> ist sehr m√§chtig, aber komplex ‚Äì mit √úbung aber leicht beherrschbar.</li>
    <li>Wichtige Konzepte:
      <ul style="margin-top:0.5em;">
        <li>Abarbeitungsreihenfolge des SELECT-Befehls (siehe √úbersicht!)</li>
        <li>Zielgerichteter Einsatz von <b>Joins</b> (Verbund)</li>
        <li>Nutzung von <b>Unterabfragen</b> und <b>Gruppierung/Aggregation</b></li>
        <li>Beachtung von SQL-Dialekt-Unterschieden zwischen Oracle, SQL Server und MySQL</li>
      </ul>
    </li>
  </ul>
</div>

<div style="background:#12202b;padding:1em 1.7em;border-radius:1em;margin-bottom:2em;">
  <b style="color:#00f2ff;">Tipp:</b> Mit ein wenig √úbung und Neugier wird SQL vom ‚ÄûSchreckgespenst‚Äù zum echten Power-Tool!
</div>

<h3>Abweichungen von der SQL-Norm: Die gro√üen Drei im Vergleich</h3>
<table style="width:100%;background:#172233;color:#eee;margin:1.5em 0;border-radius:1em;overflow:hidden;font-size:0.99em;">
  <thead style="background:#222c3c;color:#00f2ff;">
    <tr>
      <th style="text-align:left;padding:0.7em 1em;">System</th>
      <th style="text-align:left;padding:0.7em 1em;">Abweichungen von der Norm</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="padding:0.7em 1em;"><b>Oracle</b></td>
      <td style="padding:0.7em 1em;">
        <ul style="margin:0;line-height:1.7;">
          <li><b>AS</b> im FROM-Teil nicht erlaubt</li>
          <li>EXCEPT hei√üt <b>MINUS</b></li>
          <li><b>Substring</b>-Syntax: <code>Substr(str,pos,anz)</code></li>
          <li>Im INSERT nur eine <b>VALUES</b>-Angabe erlaubt</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td style="padding:0.7em 1em;"><b>SQL Server</b></td>
      <td style="padding:0.7em 1em;">
        <ul style="margin:0;line-height:1.7;">
          <li>SELECT im FROM braucht <b>Aliasnamen</b></li>
          <li><b>NATURAL/USING</b> nicht unterst√ºtzt</li>
          <li><b>Substring</b>: <code>Substring(str,pos,anz)</code></li>
          <li>DATE als Typ/Operator nicht erlaubt</li>
          <li>Transaktion mit <b>BEGIN TRANSACTION</b></li>
        </ul>
      </td>
    </tr>
    <tr>
      <td style="padding:0.7em 1em;"><b>MySQL</b></td>
      <td style="padding:0.7em 1em;">
        <ul style="margin:0;line-height:1.7;">
          <li>SELECT im FROM braucht <b>Aliasnamen</b></li>
          <li>Nach Aggregatfunktion kein Leerzeichen erlaubt</li>
          <li><b>NATURAL INNER JOIN:</b> "INNER" nicht erlaubt</li>
          <li><b>FULL OUTER JOIN</b>, <b>EXCEPT</b> und <b>INTERSECT</b> nicht unterst√ºtzt</li>
          <li>Transaktionsbetrieb nur mit <b>InnoDB</b>-Engine</li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<div style="background:#00f2ff14;padding:1em 1.7em;border-left:6px solid #00f2ff;border-radius:0.9em;margin:2em 0;">
  <b style="color:#00f2ff;">Fazit:</b>
  <br>Wer die Grundprinzipien und die Abarbeitung von SELECT versteht, kann mit SQL jede praktische Datenbankabfrage l√∂sen ‚Äì egal welches System im Hintergrund l√§uft.
</div>
`
      },
      {
        title: "4.6 √úbungsaufgaben",
        description: "Teste dein Wissen zu SQL mit diesen Aufgaben.",
        content: `<h3>√úbungsaufgaben</h3><ul><li>Stelle eine SELECT-Abfrage zusammen, die ...</li><li>F√ºhre ein UPDATE durch, bei dem ...</li><li>... (weitere Aufgaben)</li></ul>`
      },
      {
        title: "Literatur",
        description: "Empfohlene B√ºcher und Quellen zu SQL.",
        content: `<h3>Literatur</h3><ul><li>Klassik: SQL for Smarties ‚Äì Joe Celko</li><li>Modern: Das SQL-Handbuch ‚Äì R. van der Lans</li></ul>`
      }
    ];

    const mainButtons = document.querySelectorAll('.tab-buttons button');
    const lessonContent = document.getElementById('lessonContent');
      function addVerstandenButton(container) {
      const wrap = document.createElement('div');
      const btn = document.createElement('button');
      btn.textContent = 'Verstanden';
      btn.className = 'btn-verstanden';
      wrap.appendChild(btn);
      container.appendChild(wrap);
      btn.addEventListener('click', () => {
        confetti({
          particleCount: 90,
          spread: 90,
          origin: { y: 0.75 }
        });
      });
    }


    function showContent(idx) {
      const section = sections[idx];
      let html = `<h2>${section.title}</h2><p>${section.description}</p>`;
      if (section.content) {
        html += section.content;
      }
      if (section.subsections) {
        html += `<div class="subsection-buttons">`;
        section.subsections.forEach((sub, subIdx) => {
          html += `<button data-sub="${subIdx}">${sub.name}</button>`;
        });
        html += `</div>`;
        html += `<div class="sub-content" id="subContent"></div>`;
      }
      lessonContent.innerHTML = html;
      lessonContent.classList.remove('visible');
      setTimeout(() => lessonContent.classList.add('visible'), 60);

      // Subkapitel Buttons
      const subBtns = lessonContent.querySelectorAll('.subsection-buttons button');
      const subContent = document.getElementById('subContent');
      if (subBtns.length && subContent) {
        subBtns.forEach((sb, i) => {
          sb.addEventListener('click', () => {
            subBtns.forEach(x => x.classList.remove('active'));
            sb.classList.add('active');
            subContent.innerHTML = section.subsections[i].content;
            addVerstandenButton(subContent); // <-- HIER Eingebaut
          });
        });
        subBtns[0].click();
         } else if (!section.subsections) {
        addVerstandenButton(lessonContent);
      }
    }

    mainButtons.forEach((btn, idx) => {
      btn.addEventListener('click', () => {
        mainButtons.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        showContent(idx);
      });
    });

    // Direkt beim Laden das erste Kapitel + Unterkapitel anzeigen:
    showContent(0);
    mainButtons[0].classList.add('active');
</script>
</body>
</html>
